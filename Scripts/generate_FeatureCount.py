import os
import pandas as pd
import argparse
import time
import pysam


def parse_args():
    parser = argparse.ArgumentParser()

    requiredArgs = parser.add_argument_group("Required arguments")
    
    requiredArgs.add_argument(
        "-ra",
        "--run_accession",
        dest = "run_accession",
        nargs="+",
        required=True,
        help="RunAccession Identifier of Sample"
    )

    requiredArgs.add_argument(
        "-s",
        "--sample_files",
        dest = "sample_files",
        nargs="+",
        required=True,
        help="List of fastq sample names"
    )
    
    requiredArgs.add_argument(
        "-a",
        "--AnnotationFileGenes",
        dest = "annotation_file",
        nargs="+",
        required=True,
        help=".table file containing genes in SAF"
    )
    
    return parser.parse_args()

def CalculateFraction(AnnotationDictionary):
    TotalCount = 0
    for ref in AnnotationDictionary.keys():
        TotalCount = TotalCount + AnnotationDictionary[ref]['Count'].sum()
    FractionDict = {}
    for ref in AnnotationDictionary.keys():
        Fraction = AnnotationDictionary[ref]['Count'].sum() / TotalCount
        FractionDict[ref] = Fraction
    return FractionDict


#select set of prefered references and do index for them ; run over all samples, if ref in n50 selection do analysis ; create refname_samplename_featurecount result
def main():
    args = parse_args()
    RunAccession = args.run_accession[0]
    #open all annotation file
    AnnotationTable = pd.read_table(args.annotation_file[0] , sep='\t', header = 0)
    GroupedAnnotationTable = [pd.DataFrame(y) for x,y in AnnotationTable.groupby('Chr', as_index=False)]
    #split annotation file for each genome and create dictionary containing dataframe for each genome_files
    #Add a new column to the table for storing weighted read counts
    AnnotationDictionary = {}
    for geneTable in GroupedAnnotationTable:
        geneTable = geneTable.assign(Count=lambda x: float(0))
        AnnotationDictionary[geneTable.iloc[0]['Chr']] = geneTable
    #open the bam file with pysam ; Bam file named {RA}_mapped.bam , should have {RA}_mapped.bam.bai in same location
    bamfile = pysam.AlignmentFile(F"{RunAccession}_mapped.bam","rb",require_index=True)
    NumCrAssPhageReads = bamfile.mapped
    #NH i Number of reported alignments that contain the query in the current record
    #HI i Query hit index
    #AS i Alignment score generated by aligner
    #NM i Edit distance to the reference
    #process each alignment and put them as the alignment object in a dynamic list of dictionaries for the # of alignments of that read
    ReadDictionary = {1:[]}
    for alignment in bamfile.fetch():
        NumOfAlignments = alignment.get_tag("NH")
        if NumOfAlignments not in ReadDictionary.keys():
            ReadDictionary[NumOfAlignments] = list()
        ReadDictionary[NumOfAlignments].append(alignment)
    print(F"Total & Number of reads for each # of alignments of {RunAccession}")
    print(bamfile.mapped)
    with open(F"results/4_ReferenceSelection/per_sample/{RunAccession}/{RunAccession}_Alignments.tsv", 'w') as alignmentFile:
            for i in ReadDictionary.keys():
                print(F"{i}:{len(ReadDictionary[i])}")
                alignmentFile.write(F"{i}\t{len(ReadDictionary[i])}\n")
    
    #process each ReadDictionary's ReadLists and calculate weighted count values for their aligned gene
    Alignments = ReadDictionary[1]
    for alignment in Alignments:
        Reference = alignment.reference_name
        Start = alignment.reference_start
        End = alignment.reference_end
        Length = alignment.query_length
        AnnoDF = AnnotationDictionary[Reference]
        #read lies inside gene ;  alternatively read starts in, ends out OR starts out ends in at 75%  atleast inside ; add boundary's extending gene to compensate 25% of read length
        GenesStartIn = AnnoDF[(AnnoDF['Start'] <= Start) & ((AnnoDF['End'] + 0.25*Length) >= End)]
        GenesEndIn = AnnoDF[((AnnoDF['Start'] - 0.25*Length) <= Start) & (AnnoDF['End'] >= End)]
        Genes = GenesStartIn.append(GenesEndIn).drop_duplicates()
        if len(Genes) == 0:
            continue #No Alignment in gene skip this read
        for idx, geneRow in Genes.iterrows():
            Ref = geneRow['Chr']
            Index = idx
            #Add to the count of found gene in the DF of the genome in the AnnotationDictionary
            AnnotationDictionary[Ref].at[Index,'Count'] = AnnotationDictionary[Ref].at[Index,'Count'] + 1.0   
    #Now process all the MM's weighted by the Unique's and the previous-level MM's
    for i in range(2, max(ReadDictionary.keys()) + 1):
        #because i can not be in the dict (say read maps 6 times and 8 times but not 7)
        if i not in ReadDictionary.keys():
            continue
        MultiMappers = ReadDictionary[i]
        FractionDict = CalculateFraction(AnnotationDictionary)
        with open(F"results/4_ReferenceSelection/per_sample/{RunAccession}/{RunAccession}_Fractions.tsv", 'a') as fractionFile:
            for ref in FractionDict.keys():
                fractionFile.write(F"{i}\t{ref}\t{FractionDict[ref]}\n")
        for alignment in MultiMappers:
            Reference = alignment.reference_name
            Start = alignment.reference_start
            End = alignment.reference_end
            AnnoDF = AnnotationDictionary[Reference]
            #read lies inside gene ;  alternatively read starts in, ends out OR starts out ends in at 75%  atleast inside ; add boundary's extending gene to compensate 25% of read length
            GenesStartIn = AnnoDF[(AnnoDF['Start'] <= Start) & ((AnnoDF['End'] + 0.25*Length) >= End)]
            GenesEndIn = AnnoDF[((AnnoDF['Start'] - 0.25*Length) <= Start) & (AnnoDF['End'] >= End)]
            Genes = GenesStartIn.append(GenesEndIn).drop_duplicates()
            if len(Genes) == 0:
                continue #No Alignment in gene skip this read
            for idx, geneRow in Genes.iterrows():
                Ref = geneRow['Chr']
                Index = idx
                #Add to the count of found gene in the DF of the genome in the AnnotationDictionary weighted by its abundance
                AnnotationDictionary[Ref].at[Index,'Count'] = (AnnotationDictionary[Ref].at[Index,'Count'] + (1 * FractionDict[Ref]))
    
    #Save original annotation dictionary for manual inspection
    with open(F"results/4_ReferenceSelection/per_sample/{RunAccession}/{RunAccession}_Annotation.tsv", 'w') as annoFile:
        annoFile.write(F"RunAccession\tGenome\tGeneID\tCount\n")
        for ref in AnnotationDictionary.keys():
            for row in AnnotationDictionary[ref].itertuples():
                #print all rows that actually contain data to tsv   # RunAccession	Genome	GeneID	Count
                if row.Count > 0.0:
                    split = row.GeneID.split("_")[0:2]
                    GeneID = split[0] + "_" + split[1]
                    Count = row.Count
                    annoFile.write(F"{RunAccession}\t{ref}\t{GeneID}\t{Count}\n")
    #Take the Counts, calculate the RPKM, export to tsv for this RA RPKM = ((GeneHitCount/(NumCrAssPhageReads / 1000000))/GeneLength)
    with open(F"results/4_ReferenceSelection/per_sample/{RunAccession}/{RunAccession}_RPKM.tsv", 'w') as rpkmFile:
        rpkmFile.write(F"RunAccession\tGenome\tGeneID\tRPKM\n")
        for ref in AnnotationDictionary.keys():
            if len(AnnotationDictionary[ref][AnnotationDictionary[ref].Count > 0]) > 0:
                AnnotationDictionary[ref] = AnnotationDictionary[ref].assign(Count=lambda x: (x['Count']/(NumCrAssPhageReads/1000000))/(x['End']-x['Start'])) #Counts -> RPKM
                for row in AnnotationDictionary[ref].itertuples():
                    #print all rows that actually contain data to tsv   # RunAccession	Genome	GeneID	RPKM
                    if row.Count > 0.0:
                        split = row.GeneID.split("_")[0:2]
                        GeneID = split[0] + "_" + split[1]
                        RPKM = row.Count
                        rpkmFile.write(F"{RunAccession}\t{ref}\t{GeneID}\t{RPKM}\n")
    
            
    
if __name__ == "__main__":
    main()